
package main

import (
    "bufio"
    "fmt"
    "os/exec"
    "strings"
    "testing"
    "time"
)

func TestConnectToRouter16(t *testing.T) {
    cmd := exec.Command("docker", "exec", "-it", "clab-frrlab-router2", "/bin/bash")

    // Connect to the command's standard input
    stdin, err := cmd.StdinPipe()
    if err != nil {
        fmt.Println("Error obtaining stdin pipe:", err)
        return
    }

    // Connect to the command's standard output
    stdout, err := cmd.StdoutPipe()
    if err != nil {
        fmt.Println("Error obtaining stdout pipe:", err)
        return
    }

    // Start the command
    if err := cmd.Start(); err != nil {
        fmt.Println("Error starting command:", err)
        return
    }

    // Create a scanner to read from the command's output
    scanner := bufio.NewScanner(stdout)

    // Wait a moment to let the shell start up
    time.Sleep(2 * time.Second)

    // Enter vtysh mode
    fmt.Fprintln(stdin, "vtysh")

    // Wait for the prompt indicating vtysh mode
    waitForPrompt(scanner, "router#")

    // Enter configure terminal mode
    fmt.Fprintln(stdin, "configure terminal")

    // Wait for the prompt indicating configure terminal mode
    waitForPrompt(scanner, "router(config)#")

    // Exit the shell
    fmt.Fprintln(stdin, "exit")

    // Wait for the shell to exit
    if err := cmd.Wait(); err != nil {
        fmt.Println("Error waiting for command to exit:", err)
        return
    }
}

func waitForPrompt(scanner *bufio.Scanner, prompt string) {
    for scanner.Scan() {
        line := scanner.Text()
        if strings.Contains(line, prompt) {
            break
        }
    }
}
