
package main

import (
    "bufio"
    "fmt"
    "os/exec"
    "strings"
    "testing"
)

func TestConnectToRouter16(t *testing.T) {
    // Create the docker exec command
    cmd := exec.Command("docker", "exec", "-i", "clab-frrlab-router2", "/bin/bash")

    // Connect to the command's standard input, output, and error
    stdin, err := cmd.StdinPipe()
    if err != nil {
        fmt.Println("Error obtaining stdin pipe:", err)
        return
    }
    stdout, err := cmd.StdoutPipe()
    if err != nil {
        fmt.Println("Error obtaining stdout pipe:", err)
        return
    }

    // Start the command
    if err := cmd.Start(); err != nil {
        fmt.Println("Error starting command:", err)
        return
    }

    // Create a scanner to read from the command's output
    scanner := bufio.NewScanner(stdout)

    // Send commands and read output sequentially
    sendCommand := func(cmd string) {
        _, err := fmt.Fprintln(stdin, cmd)
        if err != nil {
            fmt.Println("Error sending command:", err)
        }
    }

    // Expect functions
    expect := func(expected string) {
        for scanner.Scan() {
            line := scanner.Text()
            fmt.Println("Output:", line)
            if strings.Contains(line, expected) {
                fmt.Println("Prompt detected:", expected)
                break
            }
        }
    }

    // Send commands and expect prompts
    sendCommand("vtysh")
    expect("router#")
    sendCommand("configure terminal")
    expect("router(config)#")
    sendCommand("exit")
    expect("#")
    sendCommand("exit")

    // Wait for the command to finish
    if err := cmd.Wait(); err != nil {
        fmt.Println("Error waiting for command to exit:", err)
        return
    }
}
