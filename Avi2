
package main

import (
	"fmt"
	"github.com/kr/pty"
	"io"
	"os"
	"os/exec"
	"strings"
	"syscall"
	"time"
)

func main() {
	// Start the docker exec command
	cmd := exec.Command("docker", "exec", "-it", "clab-frrlab-router2", "/bin/bash")

	// Start a pseudo-terminal (pty) for interaction
	ptyMaster, tty, err := pty.Open()
	if err != nil {
		fmt.Println("Error opening pty:", err)
		return
	}
	defer ptyMaster.Close()

	// Set cmd's stdin, stdout, and stderr to the pty
	cmd.Stdin = tty
	cmd.Stdout = tty
	cmd.Stderr = tty

	// Start the command
	if err := cmd.Start(); err != nil {
		fmt.Println("Error starting command:", err)
		return
	}

	// Create a reader for the command's output
	cmdOutputReader, err := cmd.StdoutPipe()
	if err != nil {
		fmt.Println("Error obtaining command's stdout pipe:", err)
		return
	}

	// Create a writer for the command's input
	cmdInputWriter := io.MultiWriter(ptyMaster, os.Stdout)

	// Wait for the command to display the prompt
	waitForPrompt(cmdOutputReader, "router#", 10*time.Second)

	// Send commands
	sendCommand(cmdInputWriter, "configure terminal")
	waitForPrompt(cmdOutputReader, "router\\(config\\)#", 10*time.Second)

	// Send exit commands
	sendCommand(cmdInputWriter, "exit")
	waitForPrompt(cmdOutputReader, "router#", 10*time.Second)
	sendCommand(cmdInputWriter, "exit")
	waitForPrompt(cmdOutputReader, "#", 10*time.Second)

	// Wait for the command to exit
	if err := cmd.Wait(); err != nil {
		fmt.Println("Error waiting for command to exit:", err)
		return
	}
}

// sendCommand sends a command to the command's input
func sendCommand(writer io.Writer, cmd string) {
	fmt.Println("Sending command:", cmd)
	_, err := fmt.Fprintf(writer, "%s\r", cmd)
	if err != nil {
		fmt.Println("Error sending command:", err)
	}
}

// waitForPrompt waits for the command to display the specified prompt
func waitForPrompt(reader io.Reader, prompt string, timeout time.Duration) {
	buffer := make([]byte, 1024)
	start := time.Now()

	for {
		n, err := reader.Read(buffer)
		if err != nil && err != io.EOF {
			fmt.Println("Error reading command output:", err)
			return
		}

		if strings.Contains(string(buffer[:n]), prompt) {
			fmt.Println("Prompt detected:", prompt)
			return
		}

		if time.Since(start) > timeout {
			fmt.Println("Timeout waiting for prompt:", prompt)
			return
		}

		time.Sleep(100 * time.Millisecond)
	}
}
